Cell parameters
===============

Intro
-----

So far we've seen two types of cell inputs:

* ``Input``: the standard input object for cells.
* ``InputPort``: the input object for composite cells, allowing data to be routed to internal cells.

Both input types are meant for data to stream through. But in most usecases, algorithms also need parameter-like inputs.
Parameters are used to configure our algorithm cells, and not necessarily need incoming connections. Instead, they
can be set manually.

Therefore, we add two extra types of cell inputs:

* ``RuntimeParameter``: a parameter of which the value is allowed to change while the pipeline is running. A typical
  example of a runtime parameter would be some threshold.
* ``ConfigParameter``: a parameter that is only used to configure a cell at pipeline deployment. Typical examples of
  configuration parameters are: a path to a model file to be loaded by a cell, a resource that is assigned to the cell,

Example
-------

The following example shows a simple usecase for both types of parameters.

The middle cell loads a text file
from disk containing the *Lorem ipsum* (a Latin text, often used as dummy text). It will count how often a random
character, generated by the source cell, appears in the first *X* characters of the *Lorem ipsum*. The variable *X*
can be modified at runtime.


.. figure:: /data/pypipeline-docs-getting-started-parameters.png

   An example pipeline, showing the use of runtime- and configuration parameters (resp. orange and red). It counts
   the number that a random character appears in the first *X* characters of the *Lorem ipsum*.


.. code-block:: python
   :emphasize-lines: 3,12,13,20,28

    from typing import Optional
    from pypipeline.cell import ASingleCell
    from pypipeline.cellio import Output, Input, ConfigParameter, RuntimeParameter
    from pathlib import Path


    class LoremIpsumCounterCell(ASingleCell):

        def __init__(self, parent_cell: Optional[ACompositeCell], name: str):
            super(LoremIpsumCounterCell, self).__init__(parent_cell, name=name)

            self.config_file_path: ConfigParameter[Path] = ConfigParameter(self, "config_file_path")
            self.param_x: RuntimeParameter[int] = RuntimeParameter(self, "X")
            self.input_character: Input[str] = Input(self, "input_char")

            self.output_count: Output[str] = Output(self, "output_count")

            self.lorem_ipsum_text: Optional[str] = None

        def _on_deploy(self) -> None:
            super(LoremIpsumCounterCell, self)._on_deploy()

            file_path = self.config_file_path.pull()
            assert file_path.exists()
            with open(file_path, "r") as f:
                self.lorem_ipsum_text = f.read()

        def _on_undeploy(self) -> None:
            super(LoremIpsumCounterCell, self)._on_undeploy()

            self.lorem_ipsum_text = None

        def _on_pull(self) -> None:
            char_to_count = self.input_character.pull()
            x = self.param_x.pull()

            count = self.lorem_ipsum_text[:x].count(char_to_count)
            result = f"Character {char_to_count} appears {count} times in the first {x} characters of the Lorem ipsum."
            self.output_count.set_value(result)


Let's zoom in a bit. First of all, the parameters are created in exactly the same way as normal inputs our outputs:

.. code-block:: python

     class LoremIpsumCounterCell(ASingleCell):

         def __init__(self, parent_cell: Optional[ACompositeCell], name: str):
            ...
            self.config_file_path: ConfigParameter[Path] = ConfigParameter(self, "config_file_path")
            self.param_x: RuntimeParameter[int] = RuntimeParameter(self, "X")
            ...

You'll notice that we'll often add a prefix to the names of cell IO objects that reflect the type of IO. For example,
inputs are often named ``self.input_A``, outputs ``self.output_A``, configuration parameters ``self.config_A`` and
runtime parameters ``self.param_A``. This is just a personal convention to help with autocompletion, and not imposed
by PyPipeline in any way.

The following methods are new:

.. code-block:: python

     class LoremIpsumCounterCell(ASingleCell):

         ...

         def _on_deploy(self) -> None:
             super(LoremIpsumCounterCell, self)._on_deploy()

             file_path = self.config_file_path.pull()
             assert file_path.exists()
             with open(file_path, "r") as f:
                 self.lorem_ipsum_text = f.read()

         def _on_undeploy(self) -> None:
             super(LoremIpsumCounterCell, self)._on_undeploy()

             self.lorem_ipsum_text = None


These methods are called when the cell gets deployed or undeployed. This is the place where your cell should acquire
resources, if needed. Make sure to always call the ``deploy()`` or ``undeploy()`` of the super class as well.

But why not just load the file in the ``__init__`` of the cell?


Parameters in scalable cells
----------------------------

Remember that the internal cell in a scalable cell doesnâ€™t do any operation on the data itself. It's the clones that
you create when scaling up, that divide the incoming data and perform the operation.

The reason to make use of the parameter objects is twofold. First of all, as the internal cell itself doesn't perform
any operation, it shouldn't acquire unnecessary resources. Therefore, the ``deploy()`` method will not be called for
the internal cell itself, only for its clones.

Secondly, when using scalable cells, the values of runtime- and configuration parameter objects will be synchronized
over all clones of the cell. The internal cell acts as a proxy or remote controller to its clones: when you
change a parameter value in the internal cell, the corresponding parameter values of the clones are adjusted
accordingly, even when they run in separate processes.

.. figure:: /data/pypipeline-docs-getting-started-parameters-scalable.png

   An example pipeline, showing the use of runtime- and configuration parameters (resp. orange and red) in the context
   of a scalable cell.
